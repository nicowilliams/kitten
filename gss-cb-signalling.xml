<?xml version="1.0" encoding="UTF-8"?>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc tocindent="no"?>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc tocindent="no"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2119 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY rfc2743 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2743.xml">
<!ENTITY rfc2744 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2744.xml">
<!ENTITY rfc5056 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5056.xml">
<!ENTITY rfc5587 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5587.xml">
<!ENTITY rfc4121 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4121.xml">
<!ENTITY rfc4178 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4178.xml">
<!ENTITY rfc5653 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5653.xml">
]>
<rfc docName="draft-ietf-kitten-channel-bound-flag-01" ipr="trust200902" category="std" updates="2743, 2744">
  <front>
    <title abbrev="GSS Channel Bound Flag">Channel Binding Signalling for the Generic Security Services Application Programming Interface</title>
    <author initials="N." surname="Williams" fullname="Nicolas Williams">
      <organization abbrev="Cryptonector">Cryptonector, LLC</organization>
      <address>
        <email>nico@cryptonector.com</email>
      </address>
    </author>
    <date month="November" year="2014"/>
    <area>
Security Area
</area>
    <workgroup>
KITTEN
</workgroup>
    <keyword>Internet-Draft</keyword>
    <abstract>
      <t>
Channel binding is a technique that allows applications to use a secure channel at a lower layer without having to use authentication at that lower layer. The concept of channel binding comes from the Generic Security Services Application Programming Interface (GSS-API). It turns out that the semantics commonly implemented are different that those specified in the base GSS-API RFC (RFC2743), and that that specification has a serious bug. This document addresses both, the inconsistency as-implemented and the specification bug.</t>
      <t>
This Internet-Draft proposes the addition of a “channel bound” return flag for the GSS_Init_sec_context() and GSS_Accept_sec_context() functions. Two behaviors are specified: a default, safe behavior reflecting existing implementation deployments, and a behavior that is only safe when the application specifically tells the GSS-API that it (the application) supports the new behavior. Additional API elements are also added, including a new security context establishment API.</t>
    </abstract>
  </front>
  <middle>
    <section title="Introduction" anchor="d1e335">
      <t>
The GSS-API <xref target="RFC2743"/> supports “channel binding” <xref target="RFC5056"/>, a technique for detection of man-in-the-middle (MITM) attacks in secure channels at lower network layers. This facility is meant to be all-or-nothing: either both the initiator and acceptor use it and it succeeds, or both must not use it. This has created a negotiation problem when retrofitting the use of channel binding into existing application protocols.</t>
      <t>
Many implementations of the Kerberos V5 GSS-API mechanism <xref target="RFC4121"/> cause the acceptor to succeed when the initiator used channel binding but the acceptor application did not. This has helped deployment of channel binding in existing applications: first fix all the initiators, then fix all the acceptors. But even this technique is insufficient when there are many clients to fix, such that fixing them all will take a long time.</t>
      <t>
This document proposes a new method for deployment of channel binding that allows the feature to be enabled on the acceptor side before fixing all initiators. If the GSS-API had always had a return flag by which to indicate channel binding state then we could have had a simpler method of deploying channel binding: applications check that return flag and act accordingly (e.g., fail when channel binding is required). We cannot safely introduce this behavior now without an indication of support by the application.</t>
      <t>
It is worth noting that at least one implementor of GSS-API mechanisms (but not of the GSS-API itself) has similar semantics in its API to those proposed herein. [XXX add references to the relevant SSPI docs? -Nico]</t>
      <t>
Additionally, there may be applications where it is important for initiators to know that acceptors did use channel binding, and even to know whether a mechanism is capable of indicating as much. We add a request flag and two mechanism attributes for such applications.</t>
      <section title="Error in RFC2743" anchor="d1e375">
        <t>
The GSS-APIv2u1 <xref target="RFC2743"/> seems to indicate that mechanisms must ignore channel bindings when one party provided none. In practice some mechanisms ignore channel bindings when the acceptor provides none, but not when the initiator provides none. Note that it would be useless to allow security context establishment to succeed when the initiator does not provide channel bindings but the acceptor does, at least as long as there's no outward indication of whether channel binding was used! And indeed, the GSS-APIv2u1 does not provide any such indication. We correct this flaw in this document.</t>
      </section>
      <section title="Design" anchor="d1e390">
        <t>
This document adapts for the GSS-API C bindings a useful aspect of the Java Bindings of the GSS-API <xref target="RFC5653"/>, specifically the notion of creating an “empty” SECURITY CONTEXT handle that can then be passed to GSS_Init_sec_context() and GSS_Accept_sec_context() where they normally expect a NULL handle. This empty security context handle can then be used to set options relating to security context token establishment.</t>
        <t>
In <xref target="I-D.williams-williams-kitten-ctx-simple-async"/> we explore and extend this design to produce a more usable GSS-API (as well as support for asynchronous operation).</t>
        <section title="Application Changes" anchor="d1e414">
          <t>
This design minimizes application changes.</t>
          <t>
For initiator applications that use channel binding, the main change will be to request the new req_cb_confirmation_flag request flag and check whether the new ret_channel_bound_flag return flag is available when the security context becomes fully established.</t>
          <t>
For acceptor applications that use channel binding, the changes are as follows:</t>
          <t>
            <list style="numbers">
              <t>
Call GSS_Create_sec_context() to create an empty security context, and then</t>
              <t>
call GSS_Set_context_flags() on the empty context, setting the new req_cb_confirmation_flag request flag, before calling GSS_Accept_sec_context().</t>
              <t>
Finally, check whether the new ret_channel_bound_flag return flag is available when the security context becomes fully established.</t>
            </list>
          </t>
          <t>
If an application requests but fails to get channel binding state confirmation upon successful security context establishment, then it must act as though channel binding had not been used.</t>
          <t>
Conversely, when an application requests channel binding state confirmation and receives it at full security context establishment time, then channel binding has succeeded.</t>
        </section>
      </section>
      <section title="Alternative Design" anchor="d1e446">
        <t>
An earlier design was based on an existing, non-standard extension for carrying security context establishment options in CREDENTIAL HANDLEs. A notion of CREDENTIAL HANDLE options might still be useful for options that are really specific to credentials rather than security context tokens, but for the time being we have no use for such a thing.</t>
      </section>
      <section title="Future Directions" anchor="d1e455">
        <t>
We're likely to introduce additional mutator functions of empty contexts, with mutators corresponding to many of the existing input arguments of GSS_Init_sec_context() and GSS_Accept_sec_context(), as well as a few additional security context inquiry functions. We're also likely to then introduce new variants of GSS_Init_sec_context() and GSS_Accept_sec_context() with all of those input and output parameters removed that could be set or retrieved with the other new functions. The only inputs that the new GSS_Init/Accept_sec_context() must have are: a security context handle (never NULL), and an input context token, and the only outputs should be the status indicators and an output token. In fact, we may want to have just one new function called, perhaps, GSS_Step_sec_context(), with all the initiator and acceptor inputs and outputs other than context tokens being set/retrieved via new accessor functions, and the role of initiator or acceptor determined by whether a target principal is set..</t>
        <t>
See <xref target="I-D.williams-williams-kitten-ctx-simple-async"/>.</t>
      </section>
      <section title="Conventions used in this document" anchor="d1e473">
        <t>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"/>.</t>
      </section>
    </section>
    <section title="Channel Binding State Extension" anchor="d1e488">
      <t>
We propose a new return flag for GSS_Init_sec_context() and GSS_Accept_sec_context(), as well as a pair of functions for a) creating “empty” security context handles, b) setting req_flags and indicating which ret_flags the application understands. We also add new mechanism attributes describing mechanism capabilities.</t>
      <t>
C bindings of these extensions are provided along the lines of <xref target="RFC2744"/> and <xref target="RFC5587"/>.</t>
      <t>
In the future we might move more of the many input (and output) arguments to GSS_Init_sec_context() and GSS_Accept_sec_context() into mutators on empty security context handles.</t>
      <section title="GSS_Create_sec_context()" anchor="d1e516">
        <t>
Inputs:</t>
        <t>
          <list style="symbols">
            <t>
&lt;none&gt;</t>
          </list>
        </t>
        <t>
Outputs:</t>
        <t>
          <list style="symbols">
            <t>
major_status INTEGER</t>
            <t>
minor_status INTEGER -- note: mostly useless, but we should keep it</t>
            <t>
context SECURITY CONTEXT -- “empty” security context</t>
          </list>
        </t>
        <t>
Return major status codes:</t>
        <t>
          <list style="symbols">
            <t>
GSS_S_COMPLETE indicates success.</t>
            <t>
GSS_S_UNAVAILABLE indicates that memory is not available, for example.</t>
            <t>
GSS_S_FAILURE indicates a general failure.</t>
          </list>
        </t>
        <t>
This function creates an “empty” security context handle that can be passed to GSS_Init_sec_context() or GSS_Accept_sec_context() where they expect a NULL context. A security context is said to be “empty”, as opposed to “partially established” and “fully established” or “open”, when the context has been created by this function but not yet passed to either of GSS_Init_sec_context() or GSS_Accept_sec_context().</t>
        <section title="C-Bindings" anchor="d1e559">
          <t>
</t>
          <t>
            <figure suppress-title="true" align="center">
              <artwork> OM_uint32
 gss_create_sec_context(OM_uint32 *minor_status,
                        gss_ctx_id_t *context);</artwork>
            </figure>
          </t>
        </section>
      </section>
      <section title="New Abstract Type: FLAGS" anchor="d1e571">
        <t>
The abstract GSS-API <xref target="RFC2743"/> uses individual elements -one per-flag- instead of a “FLAGS” type. This is unwieldy, therefore we introduce an abstract type named “FLAGS” to act as a set of all the request/return flags defined for the abstract GSS-API.</t>
        <t>
The FLAGS type is a set of request/return flags.</t>
      </section>
      <section title="C-Bindings" anchor="d1e589">
        <t>
The C-bindings type for the abstract type FLAGS will be 'uint64_t' (a C99 type). I.e., up to 64 flags are now supported. More could be added in the future with additional functions like GSS_Set_context_flags().</t>
        <t>
Flags with numeric values larger than 31 should be named GSS_C_..._FLAG1 to indicate the need to use GSS_Set_context_flags() in order to use such flags. Flags with numeric values larger than 63 are out of scope for this document.</t>
      </section>
      <section title="GSS_Set_context_flags()" anchor="d1e601">
        <t>
Inputs:</t>
        <t>
          <list style="hanging">
            <t hangText="context CONTEXT HANDLE">
 </t>
            <t hangText="req_flags FLAGS">
 Requested flags. Applicable to acceptors and initiators.</t>
          </list>
        </t>
        <t>
Outputs:</t>
        <t>
          <list style="symbols">
            <t>
major_status INTEGER</t>
            <t>
minor_status INTEGER</t>
          </list>
        </t>
        <t>
Return major status codes:</t>
        <t>
          <list style="symbols">
            <t>
GSS_S_COMPLETE indicates success.</t>
            <t>
GSS_S_FAILURE indicates a general failure.</t>
          </list>
        </t>
        <t>
This function tells the mechanism (when one is eventually chosen and invoked) that the application requests the given req_flags and understands any associated ret_flags. Subsequent calls to GSS_Init_sec_context() call MUST fail with GSS_S_FAILURE if any request flags are provided to GSS_Init_sec_context().</t>
        <section title="C-Bindings" anchor="d1e645">
          <t>
</t>
          <t>
            <figure suppress-title="true" align="center">
              <artwork> OM_uint32
 gss_set_context_flags(OM_uint32 *minor_status,
                       gss_ctx_id_t context,
                       uint64_t req_flags);</artwork>
            </figure>
          </t>
        </section>
      </section>
      <section title="GSS_Get_context_flags()" anchor="d1e657">
        <t>
Inputs:</t>
        <t>
          <list style="hanging">
            <t hangText="context CONTEXT HANDLE">
 </t>
          </list>
        </t>
        <t>
Outputs:</t>
        <t>
          <list style="symbols">
            <t>
major_status INTEGER</t>
            <t>
minor_status INTEGER</t>
            <t>
ret_flags FLAGS The set of return flags available for the given context.</t>
          </list>
        </t>
        <t>
Return major status codes:</t>
        <t>
          <list style="symbols">
            <t>
GSS_S_COMPLETE indicates success.</t>
            <t>
GSS_S_FAILURE indicates a general failure.</t>
          </list>
        </t>
        <t>
This function outputs the actual return flags available on the given security context.</t>
        <section title="C-Bindings" anchor="d1e699">
          <t>
</t>
          <t>
            <figure suppress-title="true" align="center">
              <artwork> OM_uint32
 gss_get_context_flags(OM_uint32 *minor_status,
                       gss_ctx_id_t context,
                       uint64_t *ret_flags);</artwork>
            </figure>
          </t>
        </section>
      </section>
      <section title="Flag for Channel Binding State Signalling" anchor="d1e711">
        <t>
Whenever both the initiator and the acceptor provide matching channel bindings to GSS_Init_sec_context() and GSS_Accept_sec_context(), respectively, then the mechanism SHALL indicate that the context is channel bound via an output flag, ret_channel_bound_flag, for the established context.</t>
        <t>
Note that some mechanisms have no way for the acceptor to signal CB success to the initiator, in which case GSS_Init_sec_context() MUST NOT output the ret_channel_bound_flag. More generally, when a peer cannot confirm channel binding state, the local security context MUST NOT output this flag.</t>
        <section title="C-Bindings" anchor="d1e724">
          <t>
</t>
          <t>
            <figure suppress-title="true" align="center">
              <artwork> #define GSS_C_CHANNEL_BOUND_FLAG 2048 /* 0x00000800 */</artwork>
            </figure>
          </t>
        </section>
      </section>
      <section title="Request Flag for Acceptor Confirmation of Channel Binding" anchor="d1e736">
        <t>
We add a new request flag for GSS_Init_sec_context(), req_cb_confirmation_flag, to be used by initiators that insist on acceptors providing channel binding confirmation. Channel binding confirmation means that the acceptor application did provide channel bindings data and that this data matched the initiator application's channel bindings data. Initiator applications that use channel binding MUST set this request flag.</t>
        <t>
If this flag is set but channel binding data is not provided, then the peer also must have had no channel binding data, otherwise context establishment MUST fail.</t>
        <t>
If this flag is set, mechanism-negotiation pseudo-mechanisms (e.g., SPNEGO <xref target="RFC4178"/>) the pseudo-mechanism MUST NOT negotiate any mechanisms that lack the GSS_C_MA_CBINDING_CONFIRM or GSS_C_MA_CBINDING_MAY_CONFIRM mechanism attributes (see  <xref target="sub_New_Mechanism_Attributes"/>), and SHOULD NOT negotiate mechanisms that lack the GSS_C_MA_CBINDING_CONFIRM mechanism attribute (except if allowed by local configuration).</t>
        <section title="C-Bindings" anchor="d1e760">
          <t>
Because ret_channel_bound_flag (GSS_C_CHANNEL_BOUND_FLAG) is a return flag only, and req_cb_confirmation_flag is a request flag only, we can assign both the same numeric value in the C bindings to conserve precious flag bits:</t>
          <t>
</t>
          <t>
            <figure suppress-title="true" align="center">
              <artwork> #define GSS_C_CHANNEL_BOUND_FLAG 2048 /* 0x00000800 */
 #define GSS_C_CB_CONFIRM_FLAG    2048 /* 0x00000800 */</artwork>
            </figure>
          </t>
        </section>
      </section>
      <section title="New Mechanism Attributes" anchor="sub_New_Mechanism_Attributes">
        <t>
          <list style="symbols">
            <t>
We add a new mechanism attribute, GSS_C_MA_CBINDING_CONFIRM, to indicate that the initiator can and always does learn whether the acceptor application supplied channel bindings. Mechanisms advertising this attribute MUST always indicate acceptor channel bound state to the initiator when channel bindings are used by both peers and the channel bindings match, else security context establishment MUST fail (if one party provides channel bindings data but the other doesn't, or if both do and the channel bindings data don't match).</t>
            <t>
We add a new mechanism attribute, GSS_C_MA_CBINDING_MAY_CONFIRM, to indicate that the initiator may learn whether the acceptor application supplied channel bindings, but only when the acceptor implementation of the mechanism has been suitably updated. Mechanisms MUST advertise this attribute when the local initiator functionality for acceptor channel bound state indication exists and the acceptor could but might not support CB confirmation (e.g., because, for example, the mechanism predates this specification).</t>
          </list>
        </t>
        <t>
IANA: OID assignments TBD.</t>
      </section>
      <section title="GSS_Delete_sec_context() Behavior When Applied to Empty Security Contexts" anchor="d1e794">
        <t>
GSS_Delete_sec_context() MUST NOT output a context deletion token, or MUST output an empty context deletion token, when applied to ean mpty security context.</t>
      </section>
    </section>
    <section title="Modified Channel Binding Semantics" anchor="d1e803">
      <t>
The channel binding semantics of the base GSS-API are modified as follows:</t>
      <t>
        <list style="symbols">
          <t>
Whenever a) the initiator and b) the acceptor shall both have provided channel_bindings input to GSS_Init/Accept_sec_context() and the channel bindings do not match, then the mechanism MUST fail to establish a security context token. This is a restatement of an existing requirement in the base specification, restated for the reader's convenience.</t>
          <t>
Whenever the acceptor application shall have a) provided channel bindings to GSS_Accept_sec_context(), and b) not indicated support for the ret_channel_bound_flag flag, then the mechanism MUST fail to establish a security context if the initiator did not provide channel bindings data. This requirement is critical for security purposes, to make applications predating this document secure, and this requirement reflects actual implementations as deployed.

<list style="symbols"><t>
Conversely, whenever the application shall have a) provided channel bindings to GSS_Init/Accept_sec_context(), and b) indicated support for the ret_channel_bound_flag flag, then the mechanism MUST NOT fail to establish a security context just because the peer did not provide channel bindings data. The mechanism MUST output the ret_channel_bound_flag if both peers provided the same input_channel_bindings to GSS_Init_sec_context() and GSS_Accept_sec_context. The mechanism MUST NOT output the ret_channel_bound_flag if either (or both) peer did not provide channel_bindings input to GSS_Init/Accept_sec_context(). This requirement restores the original base GSS-API specified behavior, with the addition of the ret_channel_bound_flag flag.</t></list>
</t>
          <t>
Whenever the initiator application shall have a) provided channel bindings to GSS_Init_sec_context(), and b) not indicated support for the ret_channel_bound_flag flag, then the mechanism SHOULD NOT fail to establish a security context just because the acceptor failed to provide channel bindings data. This recommendation is for interoperability purposes, and reflects actual implementations that have been deployed. It is possible that not all security mechanism protocols can implement this recommendation easily.</t>
        </list>
      </t>
    </section>
    <section title="Kerberos Mechanism Binding" anchor="d1e827">
      <t>
The new request flag, GSS_C_CB_CONFIRM_FLAG, MUST be carried in the AP-REQ's Authenticator's 0x8003 “checksum” data.</t>
      <t>
When this flag is present in the initiator's AP-REQ, and in order to confirm channel binding state to the initiator when the initiator requests it (with the the req_cb_confirmation_flag flag), the acceptor MUST use key usage &lt;TBD&gt; (27?) for encrypting the AP-REP encrypted part instead of key usage 12, and the acceptor MUST use the initiator's sub-session key for encrypting the AP-REP enc-part.</t>
    </section>
    <section title="Security Considerations" anchor="d1e840">
      <t>
This document deals with security. There are no security considerations that should be documented separately in this section. To recap, this document fixes a significant flaw in the base GSS-API <xref target="RFC2743"/> specification that fortunately has not been implemented, and it adds a feature (that should have been in the base specification) for improved negotiation of use of channel binding <xref target="RFC5056"/>.</t>
    </section>
    <section title="IANA Considerations" anchor="d1e861">
      <t>
Two GSS-API mechanism attributes are to be added to the “SMI Security for Mechanism gsscma Codes” registry established by RFC5587 <xref target="RFC5587"/>. See  <xref target="sub_New_Mechanism_Attributes"/>.</t>
    </section>
  </middle>
  <back>
    <references title="Normative References">&rfc2119;
&rfc2743;
&rfc2744;
&rfc5056;
&rfc5587;
</references>
    <references title="Informative References">&rfc4121;
&rfc4178;
&rfc5653;

<reference anchor="I-D.williams-williams-kitten-ctx-simple-async"><front><title>Simplified and Asynchronous Security Context Interfaces for the Generic Security Services Application Programming Interface</title><author initials="N." surname="Williams" fullname="Nicolas Williams"><organization/></author><date month="February" day="13" year="2013"/><abstract><t>Abstract This Internet-Draft proposes extensions to the Generic Security Services Application Programming Interface (GSS-API) for replacing the exiting GSS_Init_sec_context() and GSS_Accept_sec_context() functions with simplified forms that also support asynchrony.</t></abstract></front><seriesInfo name="Internet-Draft" value="draft-williams-williams-kitten-ctx-simple-async-00"/><format type="TXT" target="http://www.ietf.org/internet-drafts/draft-williams-williams-kitten-ctx-simple-async-00.txt"/></reference>
</references>
  </back>
</rfc>
